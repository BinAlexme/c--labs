Задание

1. Добавить в меню программы команды сохранения и открытия  файлов. Реализовать сохранение рисунков в файлах и чтение их из файлов.  После сохранения файла заголовок окна соответствующего документа должен содержать имя файла. При открытии файла его имя должно использоваться в качестве заголовка окна. Пока нет ни одного открытого окна документа, команды сохранения файла должны быть в заблокированном состоянии.
2. Для  измененных  документов при закрытии окна следует выдавать диалоговое окно с запросом о сохранении  документа и обрабатывать три варианта выбора пользователя – сохранение, отказ от сохранения и отказ от закрытия окна (Yes-No-Cancel).

Краткая справка.

Классы .NET  для  операций с файловой системой  находятся в основном в пространстве имен System.IO. 
.NET включает также ряд классов и интерфейсов в пространстве имен System.Runtime.Serialization, которые связаны с сериализацией, то есть,  процессом преобразования некоторых данных (например, содержимого документа)  в поток байтов для хранения в файле или  другом объекте, к которому применимы операции последовательного ввода-вывода. Чтобы обеспечить поддержку сериализации в собственных классах достаточно  назначить им атрибут  [Serializable()]. Атрибуты в С# задают дополнительные и особые свойства элементам языка и указываются в квадратных скобках непосредственно перед тем элементом, к которому они применяются. Если классу назначен этот атрибут, все его поля данных будут по умолчанию сохранятся в файле или в другом потоковом объекте при передаче объекта этого класса методу сериализации. Чтобы исключить определённые поля класса, например, временные и вспомогательные переменные, из операции сериализации,  этим элементам  следует назначить атрибут  [NonSerialized()]

Сохранение объекта obj некоторого класса X в файле с именем fileName с использованием сериалиации может быть выполнено следующим образом:

```c#
BinaryFormatter formatter = new BinaryFormatter();
Stream stream = new FileStream(fileName, FileMode.Create, FileAccess.Write, FileShare.None);
formatter.Serialize(stream, obj);
stream.Close();

```
Восстановление сохранённого объекта из файла:

```c#
BinaryFormatter formatter = new BinaryFormatter();
Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
X obj = (X)formatter.Deserialize(stream);
stream.Close();

```
Использование классов, применяемых при сериализации, требует подключения к модулю следующих пространств имён:

```c#
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;

```


Класс List поддерживает сериализацию и при её выполнении в потоковом объекте сохраняются все элементы динамического массива. Но чтобы этот механизм работал, требуется, чтобы сами элементы массива также поддерживали сериализацию. Соответственно, классы, объекты которых  используются в качестве элементов динамического массива, должны быть сделаны сериализуемыми.

При обработке команд меню, связанных с файловыми операциями, часто используются классы .NET, которые обеспечивают создание стандартных диалоговых панелей Windows, обеспечивающих выбор файла для открытия и сохранения. Это классы OpenFileDialog и SaveFileDialog. С примерами их использования можно ознакомиться в справочной системе Visual Studio .NET.

.

Рекомендации
 
1.
Следует реорганизовать меню программы. На верхнем уровне меню слева должен находится пункт «Файл», справа – «Окно». В разделе меню «Файл» должны быть команды «Новый», «Открыть», «Сохранить», «Сохранить как…». Из раздела  «Окно» следует удалить команду «Новое», а её обработчик связать с пунктом меню «Файл»-«Новый». При обработке команд сохранения  и открытия файлов следует создавать соответствующие стандартные диалоговые панели и использовать результаты выбора пользователя для сериализации и десериализации массива фигур.  Обработчики команд «Сохранить» и «Сохранить как…» должны различаться только обработкой ранее сохранённого файла. В первом случае он должен сохраняться без создания и вывода файлового диалога. Для начальной блокировки этих пунктов меню надо установить их свойство Enabled  в значение false. При создании и закрытии окон документов следует управлять состоянием этих пунктов меню, 
блокируя и  разблокируя их в соответствии с ситуацией.
Объекты, соответствующие пунктам меню, являются полями класса родительской формы. Из методов дочернего окна можно обратиться к родительской форме через свойство ParentForm.

При инициализации файловых диалогов следует указывать в качестве стартового каталога текущий каталог программы. Это можно сделать  следующим образом:

```c#
saveFileDialog.InitialDirectory = Environment.CurrentDirectory;

```

В поле Filter классов файловых  диалогов следует задавать шаблон, соответствующий имени вашего редактора и расширению файлов рисунков, создаваемых в нём.
Чтобы обратиться в коде родительской MDI-формы к полям сохраняемой дочерней формы, можно использовать свойство this.ActiveMdiChild, содержащее ссылку на активное окно документа. Для изменения заголовка окна можно в программе изменять значение свойства формы Text. 

2. 
Для обработки попытки закрытия окна формы следует в дочерней MDI-форме реализовать обработчик события FormClosing. Окно запроса о сохранении   документа следует выдавать только при наличии изменений в документе. То есть, оно не должно выдаваться при закрытии пустого окна или окна, отображающего документ, прочитанный из файла или записанный в файл и не содержащий изменений. Для отслеживания соответствующих состояний документа следует добавить в класс формы переменную - флаг модификации документа. Чтобы метод MessageBox.Show создавал окно с тремя кнопками, в качестве третьего аргумента ему следует передавать константу MessageBoxButtons.YesNoCancel. Метод в данном случае может возвращать константы DialogResult.Yes, DialogResult.No, DialogResult.Cancel.
Отказ от закрытия формы (выбор Cancel) должен приводить к установке в true свойства Cancel второго аргумента  обработчика события FormClosing. 
