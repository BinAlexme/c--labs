# **ЛАБОРАТОРНАЯ РАБОТА №11**
**“Операции с буфером обмена и метафайлом.  Использование  функций API Windows"**
###

Задание

1 Добавить в редактор раздел «Правка» в меню верхнего уровня. Реализовать операции и команды меню:

1) Копирование выделенного блока в системный буфер обмена (Clipboard) в собственном формате
1) ` `Копирование блока в Clipboard в формате метафайла. 
1) Вырезание блока (копирование в буфер  с удалением).
1) ` `Вставка блока (в собственном формате) из буфера.
1) «Выделить все» 

2	Команды меню, вызывающие операции с буфером обмена, должны блокироваться при отсутствии окон рисунков  и при отсутствии в рисунке активной формы выделенного блока (для команд копирования и вырезания).

Команда вставки из буфера должна блокироваться при отсутствии в буфере информации нужного формата.

3. При вставке в новое окно блок должен позиционироваться в левый верхний угол рисунка, вне зависимости от его положения в исходном рисунке. Если размеры блока превышают размеры рисунка, вставка выполняться не должна, а должно выводиться окно с сообщением о том, что блок превышает допустимые размеры.
3. Для  метафайла, передаваемого в буфер,  следует проверить  возможность вставки из буфера в программы MS Word, Excel, Paint.



**Краткая справка.**

**Буфер обмена – Clipboard**

Буфер информационного обмена Windows предназначен для межпрограммного обмена данными и функционирует как хранилище данных различного формата. Каждое приложение Windows, которое помещает данные в буфер информационного обмена, может использовать стандартный  формат данных или  свой собственный. 

Данные, помещенные в Буфер информационного обмена, могут быть получены теми приложениями, которые распознают  формат этих данных.

Программы, работающие е документами или другими данными, предоставляют пользователю доступ к буферу обмена через стандартные пункты меню «Вырезать», «Копировать» и  «Вставить». Когда пользователь выбирает «Вырезать» или «Копировать», программа передает выбранные данные из приложения в буфер обмена. Данные имеют определенный формат или форматы: обычно это текст, растровое изображение, метафайл или двоичные данные, Команда «Вырезать», кроме того, удаляет выделенные данные из документа. Когда пользователь выбирает в меню пункт «Вставить», программа определяет, содержатся ли и буфере обмена данные, с которыми она может работать. Если да, то они передаются из буфера в программу. Программа не должна передавать данные в буфер обмена без явного указания со стороны пользователя: выполняя операцию «Вырезать» или «Копировать»,  он вправе рассчитывать, что данные останутся в буфере обмена до следующей операции вырезания или копирования.

Класс Clipboard входит в пространство имен System.Windows.Forms. Этот класс изолированный, и у него нет открытых конструкторов. Нельзя создать экземпляр данного класса и нельзя унаследовать от него другой класс. У класса нет свойств  - есть лишь два статических метода, один из которых имеет две версии. Эти методы служат для помещения данных в буфер обмена или получения данных из буфера обмена:

Статические методы Clipboard:

void SetDataObject(object obj)

void SetDataObject(object ob], bool bRemainAfterExit)

IDataObject GetDataObject()

Для размещения в буфере обмена объекта str типа string следует вызвать метод 

Ciipboard.SetDataObject(str, true);

Данные, которые перед этим были в буфере обмена, будут удалены и заменены на этот элемент. Аналогично можно поместить в буфер растровое изоражение;

Clipboard.SetDataObject(bitmap, true);

Кроме того, в буфер обмена можно поместить метафайл:

Clipboard.SetDataObject(metafile, true);

Во всех случаях при выполнении указанных выше методов в буфер помещается копия оригинального объекта. Если изменять его содержание уже после передачи объекта в буфер обмена, эти изменения не скажутся на копии, хранимой в буфере.

Если в качестве значения второго аргумента метода SetDataObject указывать false, данные будут удалятся из буфера по завершении программы, переславшей  эти данные в буфер.

Извлечение данных из буфера требует большего числа действий. Сначала требуется вызвать метод  GetDataObject . Этот метод определен как возвращающий экземпляр класса, реализующего интерфейс IDataObject, т. е.,  GetDataObject вызывается так:

IDataObject data = Clipboard.GetDataObject()

В IDataObject определяются 4 метода (12, если учитывать перегрузки), в том числе:

bool GetDataPresent(Type type)

object GetData(Type type)

Если у вас имеется объект data, возвращаемый Clipboard.GetDataObject, то выражение:

data.GetDataPresent (typeof( String)) 

возвращает true, если к буфере обмена содержится объект String. Обратите внимание, как оператор typeof применяется для получения объекта Туре, идентифицирующего класс String. Аналогично:

data.GetDataPresent(typeof(Bitmap))  

возвращает true, если и буфере обмена находится объект Bitmap, а:

data.GetDataPresent(typeof(Metafile))

возвращает true, если доступен объект Metafile.  Для нестандартных типов данных в буфере обмена  можно использовать вызов:

data.GetDataPresent(typeof(MyType))

Буфер обмена может одновременно содержать объекты нескольких  форматов. Приложение, получающее данные из буфера,  должно выбирать среди этих форматов наиболее подходящий.

Получить объект из буфера обмена позволяет метод GetData,

string str = (string) data.GetData(typeof(string));

Так как GetData возвращает object, возвращаемое значение нужно привести к требуемому типу данных. Аналогично:

Bitmap bitmap = (Bitmap) data.GetData(typeof(Bitmap));

Дальнейшие операции с объектом из буфера обмена не влияют на содержимое буфера обмена.

Для  использования собственного формата буфера обмена следует  создать имя для этого формата, записать его в string и задействовать этот объект string в качестве формата буфера обмена. Чтобы избежать конфликтов с другими приложениями, также использующими собственные форматы, нужно давать форматам гарантированно уникальные имена. Этого легко добиться, задавая имя приложения как составную часть имени формата буфера обмена.

Метод SetData интерфейса IDataObject  позволяет применить DataObject для одновременного размещения в буфере  нескольких форматов данных:

void SetData(Type typeFormat, object objData)

Сначала создается объект типа DataObject, затем при помощи SetData в него записывается несколько форматов одного элемента, и затем объект DataObject передается методу ClipboardSetDataObject.

**Метафайлы.**

Метафайлы – файлы, в которых сохраняются сценарии вызова графических функций. Метафайлы могут сохранятся на диске или в виде объектов в памяти и воспроизводиться (формировать изображение) средствами  Windows. Метафайлы могут  использоваться для обмена графическими данными через буфер обмена между различными приложениями.

Метафайлы поддерживались в Windows, начиная с версии 1.0 (1985). Первоначальный формат метафайлов теперь называется Windows Metafile, а файлам, записанным в этом формате, присваивается расширение .wmf. С появлением 32-битных версий Windows метафайлы усовершенствованы, и введен новый формат Enhanced Metafile. Файлы, записанные и этом формате, имеют расширение.emf. 32-битные версии Windows поддерживают и старый и новый формат метафайлов. Графическая система GDI+, используемая в Windows Forms, содержит ряд новых команд рисования, имеющих отношение к метафайлам. Усовершенствованные метафайлы, содержащие команды GDI+, называются метафайлами EMF+ (EMF-плюс), однако хранятся в EMF-файлах. Windows Forms также может создавать метафайлы, совместимые со стандартным форматом EMF.

Для загрузки метафайла с диска можно использовать  статический метод FromFile класса Image:

Image image = Image.FromFile("PrettyPicture.emf");

` `Для вывода метафайла на экран служит один из методов DrawImage или DrawImageUnscaled класса Graphics:

grfx.DrawImage(image, x, у);

Как и класс Bitmap класс Metafile наследует классу Image.

Класс Metafile и относящиеся к нему классы и перечисления определены в пространстве имен System.Drawing.lmaging.

Конструкторы Metafile (выборочно)

Metafile(string strFileName)

Metafile(Stream stream)

Эти два конструктора во многом эквивалентны соответствующим статическим методам FromFile класса Image за исключением того, что они явно возвращают объект типа Metafile:

Metafile mf = new Metafile("PrettyPicture.emf");

Для создания нового метафайла в памяти следует использовать конструктор, который получает дескриптор контекста устройства, связанного с формой,  и тип метафайла. Получить дескриптор контекста можно через метод GetHdc класса Graphics. Тип дескриптора, как и большинство типов API Windows, в C# обрабатываются как тип IntPtr.

Пример инициализации нового метафайла

Graphics gr = CreateGraphics();

` `IntPtr dc = gr.GetHdc();

` `Metafile mf = new Metafile(dc, EmfType.EmfOnly);

` `gr.ReleaseHdc(dc);

` `gr.Dispose();

Так как класс Metafile наследуется от Image, для отображения метафайла используются такие же методы:

grfx.DrawIinage(mf, x, у);

Для вывода графической информации в метафайл следует получать объект Graphics вызовом статического метода Graphics.FromImage и вызывать через него стандартные  методы,  выполняющие рисование графических элементов.

Следует иметь ввиду, что  если метафайл загружен из файла или потока, то не удастся  получить объект Graphics для изменения метафайла, используя статический метод FromImage. Этот метод должен использоваться  для новых метафайлов, создаваемых вашей программой. 

Чтобы отобразить метафайл в оригинальном размере следует использовать версию метода Drawlmage, которая получает размеры метафайла:

Drawlmage(mf, х, у, mf.Width, mf.Height);


***Рекомендации***

Пункт 1. 

Для передачи через буфер обмена данных в собственном формате редактора  удобно воспользоваться классом MemoryStream, обеспечивающим сериализацию объектов в буфер, расположенный в оперативной памяти. По аналогии с операцией сохранения рисунка в файле следует сохранять массив фигур, входящих в блок,  в объекте  класса MemoryStream и затем передавать этот объект буферу обмена. Объект MemoryStream  можно создать, используя конструктор, не получающий аргументов. Операция вставки должна получать этот объект из буфера, выполнять десериализацию массива и добавлять фигуры вставляемого блока к основному рисунку.

Для записи в буфер метафайла, доступного другим приложениям Windows, следует  воспользоваться функциями API Windows, так как классы  NET.Framework реализуют эту операцию некорректно.

Следует добавить к проекту класс, инкапсулирующий соответствующие функции.

Класс содержит объявление шести внешних статических функций,  входящих в динамические библиотеки user32.dll и gdi32.dll, а также собственный метод  PutEnhMetafileOnClipboard, передающий метафайл в буфер обмена. Для объявления функций, импортируемых из стандартных DLL Windows, используется соответствующий атрибут DllImport. Первым аргументом в метод  PutEnhMetafileOnClipboard должен передаваться дескриптор окна Windows, вторым – ссылка на объект метафайла. Дескриптор окна доступен в классе формы через свойство Handle.

Текст класса ClipboardMetafileHelper:

using System.Drawing.Imaging;

using System.Runtime.InteropServices;

namespace ***<здесь надо указать имя пространства вашего приложения>***

{

public class ClipboardMetafileHelper

{

`	`[DllImport("user32.dll")]

`	`static extern bool OpenClipboard(IntPtr hWndNewOwner);

`	`[DllImport("user32.dll")]

`	`static extern bool EmptyClipboard();

`	`[DllImport("user32.dll")]

`	`static extern IntPtr SetClipboardData(uint uFormat, IntPtr hMem);

`	`[DllImport("user32.dll")]

`	`static extern bool CloseClipboard();

`	`[DllImport("gdi32.dll")]

`	`static extern IntPtr CopyEnhMetaFile(IntPtr hemfSrc, IntPtr hNULL);

`	`[DllImport("gdi32.dll")]

`	`static extern bool DeleteEnhMetaFile(IntPtr hemf);

`	`static public bool PutEnhMetafileOnClipboard( IntPtr hWnd, Metafile mf )

`	`{

`		`bool bResult = false;

`		`IntPtr hEMF, hEMF2;

`		`hEMF = mf.GetHenhmetafile(); 

`		`if( ! hEMF.Equals( new IntPtr(0) ) )

`		`{

`			`hEMF2 = CopyEnhMetaFile( hEMF, new IntPtr(0) );

`			`if( ! hEMF2.Equals( new IntPtr(0) ) )

`			`{

`				`if( OpenClipboard( hWnd ) )

`				`{

`					`if( EmptyClipboard() )

`					`{

IntPtr hRes = SetClipboardData( 14 /\*CF\_ENHMETAFILE\*/, hEMF2 );

`						`bResult = hRes.Equals( hEMF2 );

`						`CloseClipboard();

`					`}

`				`}

`			`}

`			`DeleteEnhMetaFile( hEMF );

`		`}

`		`return bResult;

`	`}

}

}

Пункт 2. 

Для управления состоянием пунктов меню можно обрабатывать событие DropDownOpening пункта  меню верхнего уровня. Это событие возникает, когда   открывается блок команд меню. Его обработка позволяет  проанализировать условия при входе в меню команд и задать соответствующие состояния пунктов меню.


