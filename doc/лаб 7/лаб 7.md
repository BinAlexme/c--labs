# **ЛАБОРАТОРНАЯ РАБОТА №7**
**“Развитие иерархии классов. Оптимизация операций рисования."**

### **Задание**

1. ` `Спроектировать классы, обеспечивающие рисование и сохранение в файлах помимо прямоугольников также  эллипсов, прямых линий  и линий произвольной формы. Рисование линии произвольной формы должно начинаться по нажатию на левую кнопку мыши и завершаться по её отпусканию.
1. Дополнить меню программы разделом «Фигура», пункты которого  должны обеспечивать выбор режима рисования одной из фигур. Пункт меню, соответствующий выбранной фигуре, должен отмечаться галочкой. Для замкнутых фигур (прямоугольника и эллипса) должны поддерживаться режимы прозрачного фона и заливки фона фигуры выбранным цветом фона. Для выбора режима заливки в меню «Фигура» ввести пункт «Заливка», который должен работать как флаг, последовательно устанавливаемый и сбрасываемый при его выборе.  Активность режима заливки должна отображаться галочкой рядом с пунктом меню.
1. Обеспечить сохранение целостности исходного изображения в процессе добавления новых фигур к рисунку (отсутствие в окне «мусора» и стёртых фрагментов фигур). Обеспечить отсутствие мерцания (мелькания фона) при добавлении новых фигур и изменении размеров окна.

**Краткая справка**.

**Прямые линии**

Для рисования одиночных прямых служит метод DrawLine класса Graphics. Есть четыре перегруженных версии DrawLine, но все они требуют один и тот же набор аргументов: координаты начальной и конечной точек линии, а также перо, которым она рисуется:

void DrawLine(Pen pen, int x1, int y1, int x2, int y2)

void DrawLine(Pen pen, float x1, float y1, float x2, float y2)

void DrawLine(Pen pen, Point pointl, Point point2)

void Drawl\_ine(Pen pen, PointF pointl, PointF point2)

Можно указывать координаты как четырьмя значениями типа int или float, так и парой структур Point или PointF.

Метод DrawLine чертит линию от первой точки до второй.

**Эллипсы**

Для рисования эллипсов служит метод DrawEllipse,  использующий те же аргументы, что и DrawRectangle:

void DrawEllipse(Pen pen, int x, int y, int cx, int cy)

void DrawEllipse(Pen pen, float, x, float y, float cx, float cy)

void DrawEllipse(Pen pen, Rectangle rect)

void DrawEllipse(Pen pen, RectangleF rectf)

Метод DrawEllipse получает координаты, определяющие углы невидимого прямоугольника, в который вписывается рисуемый этим методом эллипс. 

Заливку внутренней области эллипса выполняют методы FillEllipse класса Graphics

void FillEllipse(Brush brush, int x, int y, int cx, int cy)

void FillEllipse(Brush brush, float x, float y, float cx, float cy)

void FillEllipse(Brush brush, Rectangle rect)

void FillEllipse(Brush brush, RectangleF rectf)

**Линии произвольной формы**

В классе Graphics для рисования кривой линии может использоваться  

DrawCurve(Pen pen, Point[] apt)

DrawCurve(Pen pen, PointF[] aptf)

Для этого метода нужно задать минимум две точки. Если массив, переданный методу, содержит всего две точки, то DrawCurve соединяет их прямой. Если точек три или больше, метод рисует кривую, соединяющую все точки.

**Отмеченные пункты меню**

Windows-программы используют галочку для взаимоисключающих пунктов и для пунктов, меню, которые  могут находиться в состоянии включено/выключено. Контролировать появление галочек позволяет свойство пункта меню Checked (тип bool). Чтобы слева от пункта выводилась отметка, следует задавать true свойству Checked. Для снятия отметки – false. Для автоматического переключения отметки пункта меню следует установить в true свойство CheckOnClick. 

**Оптимизация графического вывода**

Для оптимизации графического вывода в .NET 2.0 используется  алгоритм двойной буферизации графической информации. В этом случае отдельные операции, формирующие фон и элементы изображения, выполняются с буферной областью оперативной памяти. Затем полностью сформированное изображение одной  операцией переносится в окно. 
Для активизации режима двойной буферизации в панели свойств формы следует установить в true свойство DoubleBuffered.   

Управление созданием буферов изображений в памяти обеспечивает класс BufferedGraphicsContext. Среда .NET автоматически создаёт для приложений экземпляр этого класса. Получить к нему доступ можно через свойство BufferedGraphicsManager.Current. Для объекта BufferedGraphicsContext перед использованием должен задаваться максимальный размер буфера через присваивание значения его свойству MaximumBuffer (тип Size). Максимальный размер буфера должен соответствовать максимальному размеру выводимого в окно изображения. Максимальный размер окна при текущих настройках системы можно получить, обратившись к свойству SystemInformation.PrimaryMonitorMaximizedWindowSize.

Для выполнения операций рисования  в буфере используется  объект типа BufferedGraphics.  Этот класс  содержит поле  Graphics типа Graphics.  Новый объект типа BufferedGraphics создаёт метод Allocate класса BufferedGraphicsContext. После использования объекта занятые им ресурсы  должны освобождаться методом Dispose.

Перенос сформированного рисунка из буфера в окно осуществляется методом Render класса BufferedGraphics, которому передаётся объект типа Graphics, связанный с окном.


***Рекомендации***

*Пункт 1.*

Проектирование классов эллипса и прямой линии может быть  выполнено аналогично проектированию класса прямоугольника. 

Класс линии произвольной формы для хранения множества точек, задающих линию, может использовать динамический массив. Следует учитывать, что  методу DrawCurve должен передаваться обычный массив точек, а не динамический массив.  Для рисования кривой можно формировать на основе информации из динамического массива буферный массив, координаты точек которого будут учитывать текущее положение  полос прокрутки.

*Пункт 2.*

Для управления фигурами разных типов рекомендуется определить перечисление, содержащее идентификаторы этих фигур. Выбор пункта меню, соответствующего определённой фигуре, и состояние  флага  заливки должны  фиксироваться в полях класса основной формы.  Затем, при обработке щелчка левой кнопки мыши следует учитывать значение этих параметров и создавать одну из  фигур,  используя для выбора конструкцию switch-case.



*Пункт3.*

Для формы, содержащей рисунок, установить в true свойство DoubleBuffered. Для буферизации операций рисования добавить в класс формы, содержащей рисунок, поле типа BufferedGraphics. Это поле не  должно инициализироваться в конструкторе класса, так как его инициализация требует наличия объекта Graphics, который должен создаваться лишь для уже существующих и инициализированных окон. Решением проблемы является использование для инициализации этого поля обработчика события Load формы. Это событие генерируется уже после создания формы, но  перед её первым отображением. Для освобождения ресурсов, занятых этим объектом, может использоваться обработчик события FormClosed. При создании объекта BufferedGraphics можно заполнить область окна цветом фона. Обработчик события Paint после перехода к буферизованному выводу должен заполнять фон рабочей области рисунка и рисовать фигуры, но не в окне, а в буфере, а  затем вызовом метода Render переносить сформированный рисунок в окно.

Примеры использования класса BufferedGraphics можно найти в справочной системе VisualStudio. В разделе «Index» перейдите к справке по double buffering и там по ссылке «Manually Render Buffered Graphics». 

Исключение дефектов изображения, возникающих в процессе рисования, потребует переработки алгоритмов обработки событий, приходящих от мыши. При перемещении контура фигуры вместо стирания контура в предыдущем положении теперь следует вызывать метод Render, который будет восстанавливать исходное состояние рисунка, и после этого обновлять контур. 
